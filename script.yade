# lanslide on a slope .
# import yade modules that we will use below

DROP_RADIUS = 0.2
VAR = 0.5

from yade import pack
from math import *
# create material that will be used 

#Debris Material
idConcrete=O.materials.append(FrictMat(young=30e9,poisson=.2,frictionAngle=.6,label="concrete"))
idSteel=O.materials.append(FrictMat(young=210e9,poisson=.25,frictionAngle=.8,label="steel"))
idWood=O.materials.append(FrictMat(young=13e9,poisson=.4,frictionAngle=.8,label="wood"))

#Rainfall
idWater=O.materials.append(FrictMat(young=2.2e9,poisson=.5,frictionAngle=.1,label="water"))

#Slope
idSoil=O.materials.append(FrictMat(young=80e6,poisson=.4,frictionAngle=.5,label="soil"))

#Rainfall will be a box of spheres

L = 15
B = 15
H = 5
TH = pi/4

O.bodies.append([
   facet([
      (-L*cos(TH), L*sin(TH)-0.1, B), 
      (-L*cos(TH), L*sin(TH)-0.1, -B),
      (L*cos(TH), -L*sin(TH)-0.1, B) 
   ], wire=False, material=idSoil),
   
   facet([
      (-L*cos(TH), L*sin(TH)-0.1, -B),
      (L*cos(TH), -L*sin(TH)-0.1, B), 
      (L*cos(TH), -L*sin(TH)-0.1, -B)
   ], wire=False, material=idSoil)
])


# the rain spherepack

rain=pack.SpherePack()
rain.makeCloud((-L,0,B), (L,H,-B), rMean=DROP_RADIUS, rRelFuzz=VAR)

rain.toSimulation(rot=Quaternion((0,0,1),-TH) ,material=idWater, color=(0,0,1))

# the debris spherepack

rain=pack.SpherePack()
rain.makeCloud((-L,0,B), (L,H,-B), rMean=DROP_RADIUS, rRelFuzz=VAR)

rain.toSimulation(rot=Quaternion((0,0,1),-TH) ,material=idWater, color=(0,0,1))

# NOTE : figure out irregular shapes

# create slope from facets
O.bodies.append(facet([(0,10,-5),(10,0,-5),(10,0,5)]))
O.bodies.append(facet([(10,0,5),(0,10,5),(0,10,-5)]))
# create empty sphere packing
# sphere packing is not equivalent to particles in simulation, it contains only the pure geometry
sp=pack.SpherePack()
# generate randomly spheres with uniform radius distribution
sp.makeCloud((5,15,2.5),(10,25,-2.5),rMean=.2,rRelFuzz=.5)
# add the sphere pack to the simulation
sp.toSimulation()

O.engines=[
   ForceResetter(),
   InsertionSortCollider([Bo1_Sphere_Aabb(),Bo1_Facet_Aabb()]),
   InteractionLoop(
      # handle sphere+sphere and facet+sphere collisions
      [Ig2_Sphere_Sphere_L3Geom(),Ig2_Facet_Sphere_L3Geom()],
      [Ip2_FrictMat_FrictMat_FrictPhys()],
      [Law2_L3Geom_FrictPhys_ElPerfPl()]
   ),
   NewtonIntegrator(gravity=(0,-9.81,0),damping=0.4),
   
   
]
O.dt=PWaveTimeStep()

# enable energy tracking; any simulation parts supporting it
# can create and update arbitrary energy types, which can be
# accessed as O.energy['energyName'] subsequently
O.trackEnergy=True

# if the unbalanced forces goes below .05, the packing
# is considered stabilized, therefore we stop collected
# data history and stop


O.saveTmp()

